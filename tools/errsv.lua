local product, filename = unpack(arg)

local data
do
  local env = {}
  setfenv(loadfile(filename), env)()
  data = env.WowlessLastTestFailures
end

local yaml = require('wowapi.yaml')
local write = require('pl.file').write

local getPatternValue = (function()
  local function constant(x)
    return function()
      return x
    end
  end
  local function mustnumber(x)
    return assert(tonumber(x))
  end
  local patterns = {
    {
      pattern = ': want %d+, got (%d+)$',
      value = mustnumber,
    },
    {
      pattern = ': want ".*", got "nil"$',
      value = constant(nil),
    },
    {
      pattern = ': want ".*", got nil$',
      value = constant(nil),
    },
    {
      pattern = ': want ".*", got "(.*)"$',
      value = tostring,
    },
    {
      pattern = ': want nil, got "(.*)"$',
      value = tostring,
    },
    {
      pattern = ': missing, has value (%d+)$',
      value = mustnumber,
    },
    {
      pattern = ': missing cvar ".+" with default "(.*)"$',
      value = tostring,
    },
    {
      pattern = ': missing key ".+" with value (-?%d+)$',
      value = mustnumber,
    },
    {
      pattern = ': missing key ".+" with value table: [0-9a-fA-Fx]+$',
      value = constant({}),
    },
  }

  local function forwardValue(a1, ...)
    assert(select('#', ...) == 0)
    return a1
  end

  local function forwardMatch(fn, a1, ...)
    if a1 then
      return true, forwardValue(fn(a1, ...))
    end
  end

  return function(v)
    for _, p in ipairs(patterns) do
      local match, value = forwardMatch(p.value, v:match(p.pattern))
      if match then
        return true, value
      end
    end
    print(('warning: no pattern matched %q'):format(v))
  end
end)()

local function applyPatterns(tx, ty)
  for k, v in pairs(ty) do
    if type(v) == 'table' then
      applyPatterns(tx[k], v)
    else
      local match, value = getPatternValue(v)
      if match then
        tx[k] = value
      end
    end
  end
end

local allProducts = require('wowless.util').productList()

if data.generated.cvars then
  local cvarsfile = 'data/products/' .. product .. '/cvars.yaml'
  local cvars = yaml.parseFile(cvarsfile)
  applyPatterns(cvars, data.generated.cvars)
  write(cvarsfile, yaml.pprint(cvars))
end

if data.generated.globals then
  local gf = 'data/products/' .. product .. '/globals.yaml'
  local g = yaml.parseFile(gf)
  applyPatterns(g, data.generated.globals or {})
  write(gf, yaml.pprint(g))
end

local function addProduct(products)
  local newproducts = {}
  local match = false
  for _, p in ipairs(products or {}) do
    table.insert(newproducts, p)
    match = match or p == product
  end
  if not match then
    table.insert(newproducts, product)
  end
  if #newproducts == #allProducts then
    return nil
  else
    table.sort(newproducts)
    return newproducts
  end
end

local function removeProduct(products)
  local newproducts = {}
  for _, p in ipairs(products or allProducts) do
    if p ~= product then
      table.insert(newproducts, p)
    end
  end
  return newproducts
end

for ns, nt in pairs(data.generated.apiNamespaces or {}) do
  if type(nt) == 'string' then
    if nt:match(': want "nil", got "table"$') then
      -- This means we're missing the namespace completely, but unfortunately right now
      -- generated.lua doesn't tell us what APIs are missing, so given our current data
      -- model we can't actually remedy this yet.
      assert(true)
    elseif nt:match(': want "table", got "nil"$') then
      local fn = 'data/products/' .. product .. '/apis.yaml'
      local apis = yaml.parseFile(fn)
      local pre = ns .. '.'
      for k in pairs(apis) do
        if k:sub(1, pre:len()) == pre then
          apis[k] = nil
        end
      end
      write(fn, yaml.pprint(apis))
    else
      error('unexpected string: ' .. nt)
    end
  elseif type(nt) == 'table' then
    for mn, mv in pairs(nt) do
      if mn:sub(1, 1) == '~' then
        mn = mn:sub(2)
        assert(next(mv) == 'impltype')
        assert(next(mv, 'impltype') == nil)
        assert(
          mv.impltype:match(': bad argument #1 to \'create\' %(Lua function expected%): want true, got false$'),
          mn
        )
        write(
          'data/api/' .. ns .. '.' .. mn .. '.yaml',
          yaml.pprint({
            name = ns .. '.' .. mn,
            status = 'autogenerated',
          })
        )
        local fn = 'data/products/' .. product .. '/apis.yaml'
        local apis = yaml.parseFile(fn)
        apis[ns .. '.' .. mn] = ns .. '.' .. mn
        write(fn, yaml.pprint(apis))
      else
        local apifile = 'data/api/' .. ns .. '.' .. mn .. '.yaml'
        local api = yaml.parseFile(apifile)
        if type(mv) == 'string' then
          assert(mv:match(': want "function", got "nil"$'))
          api.products = removeProduct(api.products)
        elseif type(mv) == 'table' then
          assert(next(mv) == 'impltype')
          assert(next(mv, 'impltype') == nil)
          assert(
            mv.impltype:match(': bad argument #1 to \'create\' %(Lua function expected%): want true, got false$'),
            mn
          )
          api.products = addProduct(api.products)
        else
          error('unexpected type for ' .. ns .. '.' .. mn)
        end
        write(apifile, yaml.pprint(api))
      end
    end
  else
    error('unexpected type for ' .. ns)
  end
end

do
  local fn = 'data/products/' .. product .. '/events.yaml'
  local evs = yaml.parseFile(fn)
  for k, v in pairs(data.generated.events or {}) do
    assert(v:match('Attempt to register unknown event'))
    evs[k] = nil
  end
  write(fn, yaml.pprint(evs))
end

do
  local function ensureExists(k)
    local fn = 'data/api/' .. k .. '.yaml'
    if not require('pl.file').read(fn) then
      require('pl.file').write(
        fn,
        yaml.pprint({
          name = k,
          status = 'autogenerated',
        })
      )
    end
  end
  local fn = 'data/products/' .. product .. '/apis.yaml'
  local apis = yaml.parseFile(fn)
  for k, v in pairs(data.generated.globalApis or {}) do
    if k:sub(1, 1) == '~' then
      k = k:sub(2)
      assert(next(v) == 'impltype')
      assert(next(v, 'impltype') == nil)
      assert(v.impltype:match(': bad argument #1 to \'create\' %(Lua function expected%): want true, got false$'), k)
      apis[k] = k
      ensureExists(k)
    else
      if type(v) == 'string' then
        assert(v:match(': want "function", got "nil"$'))
        apis[k] = nil
      elseif type(v) == 'table' then
        assert(next(v) == 'impltype')
        assert(next(v, 'impltype') == nil)
        assert(v.impltype:match(': bad argument #1 to \'create\' %(Lua function expected%): want true, got false$'), k)
        apis[k] = k
        ensureExists(k)
      else
        error('invalid type at globalApi ' .. k)
      end
    end
  end
  write(fn, yaml.pprint(apis))
end

for k, v in pairs(data.generated.uiobjects or {}) do
  if v.methods then
    local uf = 'data/uiobjects/' .. k .. '/' .. k .. '.yaml'
    local u = yaml.parseFile(uf)
    for mk, mv in pairs(v.methods) do
      if mv:match(': missing$') or mv:match(': product disabled: want "nil", got "function"') then
        local m = u.methods[mk]
        if not m then
          m = { products = {}, status = 'unimplemented' }
          u.methods[mk] = m
        end
        m.products = addProduct(m.products)
      end
    end
    write(uf, yaml.pprint(u))
  end
end
